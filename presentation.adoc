= C library integration in Python
include::.asciidoctorconfig[]

ifndef::live-presentation[]
== !

This is a RevealJS presentation:

* Press `S` for presentation notes
* Press `Space` or `PageDown` to change slide
* Press `Escape` to get a global view
endif::live-presentation[]

== What can we get fom the lib's file ?

=== Defines

[source, c]
--
include::resources/code/00_simple_lib.h[tag=defines]
--

[%step]
No

[.notes]
--
Define macros are interpreted by the preprocessor before any.
Do not use custom defines for PI, reuse the definition in math.h instead.
--

=== Typedefs

[source, h]
--
include::resources/code/00_simple_lib.h[tag=typedef]
--

[%step]
No

[.notes]
--

--

=== Structures

[source, h]
--
include::resources/code/00_simple_lib.h[tag=struct]
--

[%step]
No

[.notes]
--

--

=== Variables

[source, h]
--
include::resources/code/00_simple_lib.h[tag=const]
--

[source, c]
--
include::resources/code/00_simple_lib.c[tag=const]
--

[%step]
Yes

[.notes]
--

--

=== Functions

[source, h]
--
include::resources/code/00_simple_lib.h[tag=function]
--

[source, c]
--
include::resources/code/00_simple_lib.c[tag=function]
--

[%step]
Yes

== Use the lib

[step=1]
Use ctypes

[.small, step=2]
(That's it)

=== Load it

[source, py, indent=0]
--
include::resources/code/00_simple_lib.py[tag=load_dll]
--

[.notes]
--
As long as you know the path of the .dll or .so file for your system, loading said DLL in-memory for use by your program is as simple as a single function call.
--

=== Call it

[source, c]
--
include::resources/code/00_simple_lib.c[tag=function]
--

[source%step, py, indent=0]
--
include::resources/code/00_simple_lib.py[tag=funccall]
--

[quote%step]
--
include::resources/code/00_simple_lib.out[lines=1]
--

[.notes]
--
Getting back to our library's hello function, now that we know how to load a DLL, we can call it.

Ctypes is functions oriented, which makes it very easy to call simple functions simply by referencing their in-DLL name.

This will result in the expected message being written to the CLI.
--

=== Read it?

[source, c]
--
include::resources/code/00_simple_lib.c[tag=const]
--

[source%step, py, indent=0]
--
include::resources/code/00_simple_lib.py[tag=dll_resolve]
--

[quote%step]
--
include::resources/code/00_simple_lib.out[lines=2]
--

[.notes]
--
With out library's value, however, things are not so simple.

Again, ctypes is function-oriented, which means that referencing the value's name directly in the DLL will not yield the expected result.

Instead of a value, we end-up with a function pointer - not quite what we expected.
--

=== Read it!

[source, py, indent=0]
--
include::resources/code/00_simple_lib.py[tag=int_resolve]
--

[quote%step]
--
include::resources/code/00_simple_lib.out[lines=3]
--

[source%step, py, indent=0]
--
include::resources/code/00_simple_lib.py[tag=cast_resolve]
--

[quote%step]
--
include::resources/code/00_simple_lib.out[lines=4]
--

[.notes]
--
Instead of blindly referencing a value in the lib's entries, we need to tell ctypes what we want - in this case an int, which is a `c_int` in the ctypes module.

Most native types are available in `ctypes` with the `c_` prefix.

Note that another more complicated but sometimes usefull way to reference is to explicitly cast an arbitrary value (here, the function pointer) to another type (here an `int` pointer).

The result in this case is a native Python int instead of a `c_int` instance du to the array value access, one of the free footguns that come with ctypes, though its use is fairly straightforward.
--
