= C library integration in Python
include::.asciidoctorconfig[]

ifdef::initial-content[]
ifeval::["{initial-content}" != ""]
include::{initial-content}[]
endif::[]
endif::initial-content[]

== What can we get fom the lib's binary ?

=== Defines

[source, c]
--
include::resources/code/00_simple_lib/main.h[tag=defines]
--

[%step]
No

[.notes]
--
Define macros are interpreted by the preprocessor before any actual compilation occurs, thus they are not even present in the intermediate representation that will be used to generation the lib.
Also, do not use custom defines for PI. Reuse the definition in math.h instead.
--

=== Typedefs

[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=typedef]
--

[%step]
No

[.notes]
--
Types are indirectly present in all processing, however only their structural properties can be inferred by analysis from the generated lib (size), not their semantic ones (type name and source).
Programatically, no type information can be retrieved from the raw lib information.
--

=== Structures

[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=struct]
--

[%step]
No

[.notes]
--
Like types, only structural information (size, attributes locations and sizes) can be inferred via analysis from the generated lib, not their semantic ones (structure and attributes names).
Programatically, no structure information can be retrieved from the raw lib information.
The same applies for unions.
--

=== Variables

.Variable declaration in the header
[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=const]
--

.Variable definition in the lib's C code
[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=const]
--

[%step]
Yes

[.notes]
--

--

=== Functions

.Function declaration in the header
[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=function]
--

.Function definition in the lib's C code
[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=function]
--

[%step]
Yes

=== A look in the DLL

.On Linux
[source%step, bash]
--
nm -gD "my_lib.so"
objdump -T "my_lib.so" 
--

.On windows
[source%step, sh]
--
dumpbin /exports "my_lib.dll"
--

[quote%step]
.Output of the nm command
--
include::resources/code/00_simple_lib/main.dump[]
--

[.notes]
--
The Application Binary Interface of C code

The `nm` tools allows us to take a peek at the symbols table in a library's file. This symbols table contains all the entries we can reference in the DLL.

In the output, the first column is the symbol's value (e.g.: a pointer to the actual data or function's instructions' location), the second is it's type (e.g.: `T` stands for text, which is usually code/functions, while `R` stands for read-only data).

The output of this command can be used to quickly discover undocummented functions and attributes, though figuring out their parameters can be a challenge.
Here, the command shows the `normalized_radians_list_item` function that makes use of the define and struct above.
--

== Use the lib

[step=1]
Use ctypes or cffi

[.small, step=3]
(That's it)

[.notes]
--
Ctypes is python's native library to load and bind with C DLLs, while cffi needs to be loaded from pypi and may rely on external tools depending on how it's used.
--

=== Load it

[source.ctypes, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=load_dll]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=cffi_build]
--

[.notes]
--
As long as you know the path of the .dll or .so file for your system, loading said DLL in-memory for use by your program is as simple as a single function call.
--

=== Call it

[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=function]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_funccall]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=cffi_funccall]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_funccall]
--

[.notes]
--
Getting back to our library's hello function, now that we know how to load a DLL, we can call it.

For functions, simply use the function names to easily call parameters-less functions.

This will result in the expected message being written to the CLI.
--

=== Read it?

[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=const]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_dll_resolve]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_dll_resolve]
--

[.notes]
--
ctypes is function-oriented, which means that referencing a symbol on a dll will by default yield a function reference.

Thus, if we try to print the value directly, we will not get the expected result:

Instead of a value, we end-up with a function pointer - not quite what we expected.
--

=== Read it!

[source.ctypes, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_int_resolve]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_int_resolve]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_cast_resolve]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=cffi_int, indent=0]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_cast_resolve]
--

[.notes]
--
Instead of blindly referencing a value in the lib's entries, we need to tell ctypes what we expect - in this case an int, which is a `c_int` in the ctypes module.

Most native types are available in `ctypes` with the `c_` prefix.

Note that another more complicated but sometimes usefull way to reference is to explicitly cast an arbitrary value (here, the function pointer) to another type (here an `int` pointer).

The result in this case is a native Python int instead of a `c_int` instance du to the array value access, one of the free footguns that come with ctypes, though its use is fairly straightforward.
--

== C definitions in python

Who is ABI?

[.notes]
--
The Application Binary Interface is 
--

=== Simple call with parameters - int

[source, h]
--
include::resources/code/01_function_with_parameters/main.h[tag=ctypes_double_int]
--

[source, c]
--
include::resources/code/01_function_with_parameters/main.c[tag=ctypes_double_int]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_int]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=cffi_double_int, indent=0]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_int]
--

[.notes]
--
Getting back to function calls, we can just as easily call a function that takes and returns integers.

We just need to use the function's name as a reference, pass our parameter...

And boom, a 6.
--

=== Simple call with parameters - float

[source, h]
--
include::resources/code/01_function_with_parameters/main.h[tag=ctypes_double_float]
--

[source, c]
--
include::resources/code/01_function_with_parameters/main.c[tag=ctypes_double_float]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float]
--

[quote.red%step]
--
[.small]
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_ctypes]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float_ctypes]
--

[%step]
WTF?

[.notes]
--
With a function that multiplies a floating value however, things are not so simple.

Same call, let's just pass a Python float instead.

Doing so will fail as, by default, ctypes only knows to map c_int values.

Thus, we can help ctypes figure things out by explicitely providing a C float.

Though the result is not quite what we expect, unless 1 is now twice 3.5.

So, what's going on? Basically, if we directly use functions, ctypes does its best to map the parameters we provide and the return value to something useable, however it's not something that can be found from the DLL files and we should tell ctypes what it should use instead.
--

=== Specifying function types

[source, h]
--
include::resources/code/01_function_with_parameters/main.h[tag=ctypes_double_float]
--

[source.ctypes%step, py]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_return_type, indent=0]
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_return_typed, indent=0]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float_return_typed]
--

[source.ctypes%step, py]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_arg_type, indent=0]
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_arg_typed, indent=0]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=cffi_double_float, indent=0]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float_arg_typed]
--

[.notes]
--
To properly specify the function, we need to define both the return type and the parameters' type.

To specify the return type, set the function's `restype` to the desired type.

Ctypes will then be able to properly read the resulting value and return it.

Similarly, the function's `argtypes` attribute should be set to an array of types that match the function's definition.

Once this is done, ctypes becomes better at implicitely mapping provided values from python types to c types.
--

== Types

[source.ctypes, py]
--
from ctypes import (
    Array, Structure, Union, CFUNCTYPE, POINTER,
    c_int16, c_int32, c_int64, c_uint16, c_uint32, c_uint64,
    c_char, c_char_p, c_void_p, c_float, c_double, c_size_t,
)
--

[source.cffi%step, py]
--
from cffi import FFI
ffi = FFI()
--
//data_pointer = ffi.open('MyType *')

[.notes]
--
ctypes provides numerous base classes for C types that can be instanciated 
--

=== Array types

[source.ctypes, py]
--
# Fixed-size array
ctypes.c_int * 3
ctypes.c_int * 3 * 2
--

> <class '__main__.c_int_Array_3'> +
> <class '__main__.c_int_Array_3_Array_2'>

[source.ctypes, py]
--
# Array instanciation
(ctypes.c_int * 3)()
--

> <__main__.c_int_Array_3 object at 0x7f309b70bdd0>

=== Pointer types

[source.ctypes, py]
--
# Heavy pointer
ctypes.POINTER(ctypes.c_int)
--

> <class '__main__.LP_c_int'>

[source.ctypes, py]
--
# Light pointer
ctypes.byref(ctypes.c_int)
--

> <cparam 'P' (0x7fb3d7a82da0)>

=== Typedefs

[source, h]
--
typedef void* MyHandle;
typedef struct InternalStruct* InternalStructP;
--

[source.ctypes, py]
--
MyHandle = ctypes.c_void_p
class InternalStructP(ctypes.c_void_p):
  pass
--

=== Structs

[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=struct]
--

[source.ctypes, py]
--
class linked_list(ctypes.Structure):
    _pack_ = PACK

linked_list._fields_ = [
        ('value', ctypes.c_int),
        ('next', ctypes.POINTER(linked_list)),
    ]

l = linked_list(next=ctypes.pointer(linked_list(value=3)))
--

=== Packing

[source, h]
--
include::resources/code/02_structure_blob/main.h[tag=pragma]
include::resources/code/02_structure_blob/main.h[tag=datablob_struct]

include::resources/code/02_structure_blob/main.h[tag=datablob_function_declaration]
--

[source%step, c]
--
include::resources/code/02_structure_blob/main.c[tag=datablob_get_function]
--

[source.ctypes%step, py]
--
include::resources/code/02_structure_blob/main.py[tag=ctypes_datablob_class, indent=0]
--

[.notes]
--
One additional thing to be aware of is the structure packing used by the target library. As an example, let's consider this DataBlob structure with a packing of 1 and a function that returns its `d` attribute.

The function's implementation looks like this. Not much to say here.

The corresponding ctypes structure will then look like this. Note the `_pack_` attribute that should be set to 1 to match the lib's packing.
--

=== Packing

[source, py]
--
include::resources/code/02_structure_blob/main.py[tag=ctypes_function, indent=0]
--

[source.ctypes, py]
--
include::resources/code/02_structure_blob/main.py[tag=ctypes_datablob_instance, indent=0]
include::resources/code/02_structure_blob/main.py[tag=ctypes_datablob_call, indent=0]
--

[quote%hardbreaks%step]
include::resources/code/02_structure_blob/main.out[tag=ctypes_datablob]

[.notes]
--
We can then declare our ctypes interface for the function and call it with a custom object. Here, we expect the output to be `d` as it is the ASCII code stored in the variable.

Yet, if we do not match the packing expected for the structure, we will NOT get the expected value.
--

=== Packing table

.PACK=1, 2, 4, 8
[%header.zoom-80, cols='10*^']
|===
| byte | byte | byte | byte | byte | byte | byte | byte | byte | byte
| `a` | `b1` | `b2` | `b3` | `b4` | `c` | `d` 3+| **Unused**
| `a` | *_* | `b1` | `b2` | `b3` | `b4` | `c` | `d` 2+| *Unused*
| `a` | *_* | *_* | *_* | `b1` | `b2` | `b3` | `b4` | `c` | `d`
| `a` | *_* | *_* | *_* | `b1` | `b2` | `b3` | `b4` | `c` | `d`
|===

[.notes]
--
This difference is due to the fact that packing affects the internal data layout for the structure (as well as its size): if an attribute is bigger that the number of available bytes for the current bytes pack, it will be stored starting from the next empty bytes pack available.
--

== Caution, fresh memory

[.notes]
--
Now that we've gone over our application's
Things to be aware of when writing code that interacts 
--

=== Code example

[source, h]
--
include::resources/code/03_data_passaround/main.h[tag="api_tick"]
include::resources/code/03_data_passaround/main.h[tag="api_callback"]
include::resources/code/03_data_passaround/main.h[tag="api_setup_callback"]
--

[source%step, python]
--
include::resources/code/03_data_passaround/main.py[tag="api_callback_function"]
--

[source%step, python]
--
include::resources/code/03_data_passaround/main.py[tag="api_tick_cb"]
--

[quote%step]
--
include::resources/code/03_data_passaround/main.out[tag="api_tick_cb"]
--

=== !

[source, python]
--
include::resources/code/03_data_passaround/main.py[tag="api_tick_data"]
--

[quote%step]
--
include::resources/code/03_data_passaround/main.out[tag="api_tick_data"]
--

[source%step, python]
--
include::resources/code/03_data_passaround/main.py[tag="call_callback_function"]
--

[source%step, python]
--
include::resources/code/03_data_passaround/main.py[tag="call_callback"]
--

[quote%step]
--
include::resources/code/03_data_passaround/main.out[tag="call_callback"]
--

=== What happened?

[plantuml%autofit, format=svg]
----
@startuml
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/memalloc_issue.puml[]
@enduml
----

=== Memory management

* Differentiate data you initialize from the lib's data
* Use the lib's alloc/free functions if there is any
* Free the memory you allocate
* Make sure to keep tracking memory that might still be in use

== What about Epic ?

[%step]
* 64 typedefs
* 71 enums
* 190 callbacks
* 626 functions
* 687 defines
* 705 structures

[.big%step]
Not doing that.

[.small%step]
Not manually.

[.notes]
--
The counts are for the library in version 1.17.0.3.
--

=== The target

[%step]
* Be easy to maintain
* Make it easy to check changes introduced by updates
* Be reusable for other integrations of the library

=== Getting in line with steamapi.json

[%step]
* https://github.com/Ayowel/eos-sdk-json[Produce an intermediate JSON representation, window=_blank]

[mermaid%step]
----
include::resources/mermaid/map_header_to_json.mermaid[]
----

[%step]
* https://github.com/Ayowel/renpy-epicgames-eos/tree/3881e8b98af65cdf852beebc284e89bbd67dc3ca/epic_api_generator[Generate code from the intermediate JSON,window=_blank]

[mermaid%step]
----
include::resources/mermaid/map_json_to_python.mermaid[]
----

[.notes]
--
Steam's API provides a JSON file that can be used for code generation by projects that wish to integrate it,

The aim is to reproducibly create a similar file for the Epic Online Services SDK that will then be used to programmatically generate the desired definitions in Python.
--

=== A typical parameter type

[source, c]
....
/** The most recent version of the EOS_Achievements_QueryPlayerAchievements struct. */
#define EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_QueryPlayerAchievements function.
 */
EOS_STRUCT(EOS_Achievements_QueryPlayerAchievementsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievements are to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID for the user who is querying for player achievements. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));
....

[.notes]
--
This is an example of a parameter struct used by the Epic Games SDK functions.
Pretty much all functions use a similar struct, with the same ApiVersion entry which's expected value is provided through a `#define` macro.

As said previously, generic solutions tend to forego defines as they require preprocessing, which will make them disappear and - as you can see here - defines in the Epic Games SDK are load-bearing as they specify the API version being used. Thus, any solution can't just be chaining a processor and tokenizing its output.

Additionally, we want to keep comment information as they indicate which values we need to use - which also means that they will need to be parsed at some points.
--

== Getting to the intermediate representation

=== The lib's headers

[plantuml, format=svg]
----
@startuml
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/eos_include_headers.puml[]
@enduml
----

[.notes]
--
The lib's includes contain some platform-specific headers, however they only contain some platform-specifc structs that can safely be defined even on platforms that do not use them.

Another noteworthy file is `eos_base.h`, which contains all structural preprocessor macros for declarations in other files (e.g.: the EOS_STRUCT macro shown previously).

Finally, some of the `*_deprecated.inl` files actually have to be loaded as they are still referenced in functions headers.
--

=== Load the lib includes

[source, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=indexation]
----

[source, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=eos_base_overwride]
----

=== Parse lib entries

[source, h]
----
include::resources/code_samples/eos_sdk/eos_results.h[]
----

[source%step, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=eos_result_parse]
----

=== Entries parse index

[source, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=line_start_flags]
----

=== Parsing loop

[plantuml%autofit.zoom-80, format=svg]
----
@startuml
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/eos_header_parsing_loop.puml[]
@enduml
----

[.notes]
--
Special cases include EOS_UI_ preprocessor macros as they need additional context, and single-line comments which are ignored.
--

=== Resulting json

[source, json]
----
include::resources/code_samples/eos_spec/spec_sample.json[]
----

[.notes]
--
This is a very limited example of what the JSON spec file looks like.
The metadata field provides information on the current SDK version and its download source, while other fields provide lists of header file entries.
--

== Getting to the code generation

=== Load all entries

[source, py]
----
include::resources/code_samples/eos_ext/entries.py[tag=entry]
----

[.notes]
--
For generation, all entries in the spec file are mapped to specialized Entry subclasses depending on their type (function, typedef, struct, ...).
Those classes provide dependency resolution information (via requires and provides) and a way to write the content of an object.
--

=== Resolve all entries' interdependencies

[source, py]
----
include::resources/code_samples/eos_ext/entries.py[tag=function_decl]

include::resources/code_samples/eos_ext/entries.py[tag=function_requires]

include::resources/code_samples/eos_ext/entries.py[tag=function_provides]

    # ...
----

[.notes]
--
As an example, the FunctionEntry Entry subclass requires the function's parameter types and return value's type and provides the function's name.
--

=== Associate structs and functions

[source.wrap.small-code, h]
----
EOS_DECLARE_FUNC(void) EOS_Achievements_QueryDefinitions(EOS_HAchievements Handle, const EOS_Achievements_QueryDefinitionsOptions* Options, void* ClientData, const EOS_Achievements_OnQueryDefinitionsCompleteCallback CompletionDelegate);
----

[plantuml%step%autofit.zoom-70, format=svg]
----
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/ext_function_mapping.puml[]
----

[.notes]
--
As Python supports OOP while C does not, we want to be able to use the mapped structs as regular objects and call member functions instead of having to retrieve the corresponding functions manually every time.
Epic Games functions that can be used as member functions start with the name of the associated object, however we only have handles for most objects (prefixed with H) and thus need to be able to mix & match.

The matching logic splits the function's name on `_` then builds strings by joining subsets of the name's components, occasionally prefixing the second item with a `H` to match struct handles.
--

=== Write entries in order

[source, py]
----
include::resources/code_samples/eos_ext/init.py[tag=render]
----

[.notes]
--
15734 lines
--

== With cffi

// https://runebook.dev/en/articles/python/library/ctypes/ctypes._CData._objects

=== Dependencies

* python headers
* ffi headers

[.notes]
--
On Fedora: libffi-devel, libssl-devel
On Ubuntu: python3?-dev, libssl-dev, libffi-dev
--
