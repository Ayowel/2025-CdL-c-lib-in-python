= C library integration in Python
include::.asciidoctorconfig[]

ifdef::initial-content[]
ifeval::["{initial-content}" != ""]
include::{initial-content}[]
endif::[]
endif::initial-content[]

//ifndef::hide-source-repo[]
// == Sources

// https://github.com/Ayowel/2025-CdL-c-lib-in-python
// endif::hide-source-repo[]

== What can we get fom a lib's binary ?

=== Defines

[source, c]
--
include::resources/code/00_simple_lib/main.h[tag=defines]
--

[%step]
No

[.notes]
--
Define macros are interpreted by the preprocessor before any actual compilation occurs, thus they are not even present in the intermediate representation that will be used to generation the lib.
Also, do not use custom defines for PI. Reuse the definition in math.h instead.
--

=== Typedefs

[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=typedef]
--

[%step]
No

[.notes]
--
Types are indirectly present in all processing, however only their structural properties can be inferred by analysis from the generated lib (size), not their semantic ones (type name and source).
Programatically, no type information can be retrieved from the raw lib information.
--

=== Structures

[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=struct]
--

[%step]
No

[.notes]
--
Like types, only structural information (size, attributes locations and sizes) can be inferred via analysis from the generated lib, not their semantic ones (structure and attributes names).
Programatically, no structure information can be retrieved from the raw lib information.
The same applies for unions.
--

=== Variables

.Variable declaration in the header
[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=const]
--

.Variable definition in the lib's C code
[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=const]
--

[%step]
Yes

[.notes]
--

--

=== Functions

.Function declaration in the header
[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=function]
--

.Function definition in the lib's C code
[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=function]
--

[%step]
Yes

=== A look in the DLL

.On Linux
[source%step, bash]
--
nm -gD "my_lib.so"
objdump -T "my_lib.so" 
--

.On windows
[source%step, sh]
--
dumpbin /exports "my_lib.dll"
--

[quote%step]
.Output of the nm command
--
include::resources/code/00_simple_lib/main.dump[]
--

[.notes]
--
The Application Binary Interface of C code

The `nm` tools allows us to take a peek at the symbols table in a library's file. This symbols table contains all the entries we can reference in the DLL.

In the output, the first column is the symbol's value (e.g.: a pointer to the actual data or function's instructions' location), the second is it's type (e.g.: `T` stands for text, which is usually code/functions, while `R` stands for read-only data).

The output of this command can be used to quickly discover undocummented functions and attributes, though figuring out their parameters can be a challenge.
Here, the command shows the `normalized_radians_list_item` function that makes use of the define and struct above.
--

== Use the lib

[step=1]
Use ctypes or cffi

[.small, step=3]
(That's it)

[.notes]
--
Ctypes is python's native library to load and bind with C DLLs, while cffi needs to be loaded from pypi and may rely on external tools depending on how it's used.
--

=== Load it

[source.ctypes, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=load_dll]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=cffi_build]
--

[.notes]
--
As long as you know the path of the .dll or .so file for your system, loading said DLL in-memory for use by your program is as simple as a single function call with ctypes.

With CFFI however, you must declare the methods and values you expect to use before loading the DLL.
Those definitions are written in a header-like format with some limitations:

The only supported preprocessor macro is #define and may only be used to define a raw integer value.
Some modifiers such as const are not recognized.
--

=== Read DLL value with ctypes?

[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=const]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_dll_resolve]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_dll_resolve]
--

[.notes]
--
ctypes is function-oriented, which means that referencing a symbol on a dll will by default yield a function reference.

Thus, if we try to print the value directly, we will not get the expected result:

Instead of a value, we end-up with a function pointer - not quite what we expected.
--

=== Read DLL value

[source.ctypes, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_int_resolve]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_int_resolve]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_cast_resolve]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=cffi_int, indent=0]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_cast_resolve]
--

[.notes]
--
Instead of blindly referencing a value in the lib's entries, we need to tell ctypes what we expect - in this case an int, which is a `c_int` in the ctypes module.

Most native types are available in `ctypes` with the `c_` prefix.

Note that another more complicated but sometimes usefull way to reference is to explicitly cast an arbitrary value (here, the function pointer) to another type (here an `int` pointer).

The result in this case is a native Python int instead of a `c_int` instance due to the array value access, one of the free footguns that come with ctypes, though its use is fairly straightforward.
--

=== Simple function call

[source, c]
--
include::resources/code/00_simple_lib/main.c[tag=function]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=ctypes_funccall]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/00_simple_lib/main.py[tag=cffi_funccall]
--

[quote%step]
--
include::resources/code/00_simple_lib/main.out[tag=ctypes_funccall]
--

[.notes]
--
Getting back to our library's hello function, we can call it directly.

For functions, simply use the function names to easily call parameters-less functions.

This will result in the expected message being written to the CLI.
--

== C function definitions in python

[.notes]
--
As the CFFI directly parses C definitions, this section is mostly about matching C functions definitions with ctypes.
--

=== Simple call with parameters - int

[source, h]
--
include::resources/code/01_function_with_parameters/main.h[tag=ctypes_double_int]
--

[source, c]
--
include::resources/code/01_function_with_parameters/main.c[tag=ctypes_double_int]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_int]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=cffi_double_int, indent=0]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_int]
--

[.notes]
--
Getting back to function calls, we can just as easily call a function that takes and returns integers.

We just need to use the function's name as a reference, pass our parameter...

And boom, a 6.
--

=== Simple call with parameters - float

[source, h]
--
include::resources/code/01_function_with_parameters/main.h[tag=ctypes_double_float]
--

[source, c]
--
include::resources/code/01_function_with_parameters/main.c[tag=ctypes_double_float]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float]
--

[quote.red%step]
--
[.small]
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float]
--

[source.ctypes%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_ctypes]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float_ctypes]
--

[%step]
WTF?

[.notes]
--
With a function that multiplies a floating value however, things are not so simple.

Same call, let's just pass a Python float instead.

Doing so will fail as, by default, ctypes only knows to map c_int values.

Thus, we can help ctypes figure things out by explicitely providing a C float.

Though the result is not quite what we expect, unless 1 is now twice 3.5.

So, what's going on? Basically, if we directly use functions, ctypes does its best to map the parameters we provide and the return value to something useable, however it's not something that can be found from the DLL files and we should tell ctypes what it should use instead.
--

=== Specifying function types

[source, h]
--
include::resources/code/01_function_with_parameters/main.h[tag=ctypes_double_float]
--

[source.ctypes%step, py]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_return_type, indent=0]
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_return_typed, indent=0]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float_return_typed]
--

[source.ctypes%step, py]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_arg_type, indent=0]
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_arg_typed, indent=0]
--

[source.cffi%step, py, indent=0]
--
include::resources/code/01_function_with_parameters/main.py[tag=cffi_double_float, indent=0]
--

[quote%step]
--
include::resources/code/01_function_with_parameters/main.out[tag=ctypes_double_float_arg_typed]
--

[.notes]
--
To properly specify the function, we need to define both the return type and the parameters' type.

To specify the return type, set the function's `restype` to the desired type.

Ctypes will then be able to properly read the resulting value and return it.

Similarly, the function's `argtypes` attribute should be set to an array of types that match the function's definition.

Once this is done, ctypes becomes better at implicitely mapping provided values from python types to c types.
--

== Types

[source.ctypes, py]
--
from ctypes import (
    Array, Structure, Union, CFUNCTYPE, POINTER, c_int,
    c_int16, c_int32, c_int64, c_uint16, c_uint32, c_uint64,
    c_char, c_char_p, c_void_p, c_float, c_double, c_size_t,
)
char_value = c_char(b'A') # Instanciate with value b'A' (or 65)
char_value = c_int(5) # Instanciate with value 5
--

[source.cffi%step, py]
--
from cffi import FFI
ffi = FFI()
char_value = ffi.new('char*', b'A') # Single instance pointer
int_value = ffi.new('int[]', 1) # Array of size 1
int_value[0] = 5 # Set value to 5
--

[.notes]
--
ctypes provides numerous base classes for C types that can be instanciated.

To do the same thing with CFFI, call `new` with the desired object.
CFFI only allows to instanciate arrays of values.
If the instanciated struct is an explicit struct pointer instead of a sized array, the struct's fields will also be available and modifiable from its pointer reference.
--

=== Array instanciation

[source.ctypes, py]
--
(ctypes.c_int * 3)(1,2,3)
(ctypes.c_int * 3 * 2)((1,2,3), (4,5,6))
--

[%step]
> <__main__.c_int_Array_3 object at 0x7f309b70bdd0>
> <__main__.c_int_Array_3_Array_2 object at 0x7f4f82303350>

[source.cffi%step, py]
--
ffi.new('int[3]', (1,2,3))
ffi.new('int[2][3]', ((1,2,3),(4,5,6)))
--

[%step]
> <cdata 'int[3]' owning 12 bytes>
> <cdata 'int[2][3]' owning 24 bytes>

[.notes]
--
Array instanciation in ctypes relies on on-the-fly generation of meta classes that wrap the effective size of the array.
In the example, we create and instanciate an array of 3 ints, then an array of 2 arrays of 3 ints.

In CFFI, we can directly specify the array's size in the string provided to new.
If the size is not set in the string, the second parameter is expected to be the size of the array, which will then have to be initialized manually.
--

=== Pointer types

[source.ctypes, py]
--
# Heavy pointer
ctypes.POINTER(ctypes.c_int)
--

[%step]
> <class '__main__.LP_c_int'>

[source.ctypes%step, py]
--
# Light pointer
ctypes.byref(ctypes.c_int)
--

[%step]
> <cparam 'P' (0x7fb3d7a82da0)>

[.notes]
--
To use an explicit uninitialized pointer in ctypes:
Either use the POINTER class, which will create a new class to wrap the provided type and can be manipulated directly (this is what should be used when defining c functions' parameter types and return values)
Or use the byref method, which will return a light pointer that can be used as function parameter.
--

=== Functions

[source, h]
--
include::resources/code/01_function_with_parameters/main.h[tag=ctypes_double_float]
--

[source.ctypes, py]
--
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_return_type]
include::resources/code/01_function_with_parameters/main.py[tag=ctypes_double_float_arg_type]
--

=== Typedefs

[source, h]
--
typedef void* MyHandle;
typedef struct InternalStruct* InternalStructP;
typedef int* Counter;
--

[source.ctypes, py]
--
MyHandle = ctypes.c_void_p
class InternalStructP(ctypes.c_void_p):
  pass
class Counter(ctypes.POINTER(ctypes.c_int)):
  pass
--

[.notes]
--
To translate typedefs in ctypes, either assign variables to the desired type, or create new class instances (which usually results in easier debugging and clearer traces). 
--

=== Callbacks

[source, h]
--
include::resources/code/03_data_passaround/main.h[tag=api_callback]
--

[source.ctypes, py]
--
include::resources/code/03_data_passaround/main.py[tag=api_callback_decl]
include::resources/code/03_data_passaround/main.py[tag=api_callback_function]
--


=== Structures

[source, h]
--
include::resources/code/00_simple_lib/main.h[tag=struct]
--

[source.ctypes, py]
--
class linked_list(ctypes.Structure):
    _pack_ = PACK

linked_list._fields_ = [
        ('value', ctypes.c_int),
        ('next', ctypes.POINTER(linked_list)),
    ]

l = linked_list(next=ctypes.pointer(linked_list(value=3)))
--

[.notes]
--

--

=== Packing

[source, h]
--
include::resources/code/02_structure_blob/main.h[tag=pragma]
include::resources/code/02_structure_blob/main.h[tag=datablob_struct]

include::resources/code/02_structure_blob/main.h[tag=datablob_function_declaration]
--

[source%step, c]
--
include::resources/code/02_structure_blob/main.c[tag=datablob_get_function]
--

[source.ctypes%step, py]
--
include::resources/code/02_structure_blob/main.py[tag=ctypes_datablob_class, indent=0]
--

[.notes]
--
One additional thing to be aware of is the structure packing used by the target library. As an example, let's consider this DataBlob structure with a packing of 1 and a function that returns its `d` attribute.

The function's implementation looks like this. Not much to say here.

The corresponding ctypes structure will then look like this. Note the `_pack_` attribute that should be set to 1 to match the lib's packing.
--

=== Packing

[source, py]
--
include::resources/code/02_structure_blob/main.py[tag=ctypes_function, indent=0]
--

[source.ctypes, py]
--
include::resources/code/02_structure_blob/main.py[tag=ctypes_datablob_instance, indent=0]
include::resources/code/02_structure_blob/main.py[tag=ctypes_datablob_call, indent=0]
--

[quote%hardbreaks%step]
include::resources/code/02_structure_blob/main.out[tag=ctypes_datablob]

[.notes]
--
We can then declare our ctypes interface for the function and call it with a custom object. Here, we expect the output to be `d` as it is the ASCII code stored in the variable.

Yet, if we do not match the packing expected for the structure, we will NOT get the expected value.
--

=== Packing table

.PACK=1, 2, 4, 8
[%header.zoom-80, cols='10*^']
|===
| byte | byte | byte | byte | byte | byte | byte | byte | byte | byte
| `a` | `b1` | `b2` | `b3` | `b4` | `c` | `d` 3+| **Unused**
| `a` | *_* | `b1` | `b2` | `b3` | `b4` | `c` | `d` 2+| *Unused*
| `a` | *_* | *_* | *_* | `b1` | `b2` | `b3` | `b4` | `c` | `d`
| `a` | *_* | *_* | *_* | `b1` | `b2` | `b3` | `b4` | `c` | `d`
|===

[.notes]
--
This difference is due to the fact that packing affects the internal data layout for the structure (as well as its size): if an attribute is bigger that the number of available bytes for the current bytes pack, it will be stored starting from the next empty bytes pack available.
--

== Caution, fresh memory

[.notes]
--
Now that we've gone over our application's
Things to be aware of when writing code that interacts 
--

=== Code example

[source.small-code, h]
--
include::resources/code/03_data_passaround/main.h[tag="api_tick"]
include::resources/code/03_data_passaround/main.h[tag="api_callback"]
include::resources/code/03_data_passaround/main.h[tag="api_setup_callback"]
--

[source.small-code%step, py]
--
include::resources/code/03_data_passaround/main.py[tag="api_callback_function"]
--

[source.small-code%step, py]
--
include::resources/code/03_data_passaround/main.py[tag="api_tick_cb"]
--

[quote%step]
--
include::resources/code/03_data_passaround/main.out[tag="api_tick_cb"]
--

=== !

[source.small-code, h]
--
include::resources/code/03_data_passaround/main.h[tag="api_tick"]
include::resources/code/03_data_passaround/main.h[tag="api_callback"]
include::resources/code/03_data_passaround/main.h[tag="api_setup_callback"]
--

[source.small-code, py]
--
include::resources/code/03_data_passaround/main.py[tag="api_callback_function"]
--

[source.small-code%step, py]
--
include::resources/code/03_data_passaround/main.py[tag="api_tick_data"]
--

[quote%step]
--
include::resources/code/03_data_passaround/main.out[tag="api_tick_data"]
--

=== !

[source.small-code, h]
--
include::resources/code/03_data_passaround/main.h[tag="api_tick"]
include::resources/code/03_data_passaround/main.h[tag="api_callback"]
include::resources/code/03_data_passaround/main.h[tag="api_setup_callback"]
--

[source.small-code, py]
--
include::resources/code/03_data_passaround/main.py[tag="api_callback_function"]
--

[source.small-code%step, py]
--
include::resources/code/03_data_passaround/main.py[tag="call_callback_function"]
--

[source.small-code%step, py]
--
include::resources/code/03_data_passaround/main.py[tag="call_callback"]
--

[quote%step]
--
include::resources/code/03_data_passaround/main.out[tag="call_callback"]
--

=== What happened?

[plantuml%autofit, format=svg]
----
@startuml
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/memalloc_issue.puml[]
@enduml
----

=== Memory management

* Differentiate data you initialize from the lib's data
* Use the lib's alloc/free functions if there is any
* Free the memory you allocate
* Make sure to keep tracking memory that might still be in use

== What about Epic ?

[%step]
* 64 typedefs
* 73 enums
* 190 callbacks
* 628 functions
* 685 defines
* 705 structures

[.big%step]
Not doing that.

[.small%step]
Not manually.

[.notes]
--
The counts are for the library in version 1.18.1.2.
--

=== The target

[%step]
* Be easy to maintain
* Make it easy to check changes introduced by updates
* Be reusable for other integrations of the library

=== Getting in line with steamapi.json

[%step]
* https://github.com/Ayowel/eos-sdk-json[Produce an intermediate JSON representation, window=_blank]

[mermaid%step]
----
include::resources/mermaid/map_header_to_json.mermaid[]
----

[%step]
* https://github.com/Ayowel/renpy-epicgames-eos/tree/3881e8b98af65cdf852beebc284e89bbd67dc3ca/epic_api_generator[Generate code from the intermediate JSON,window=_blank]

[mermaid%step]
----
include::resources/mermaid/map_json_to_python.mermaid[]
----

[.notes]
--
Steam's API provides a JSON file that can be used for code generation by projects that wish to integrate it,

The aim is to reproducibly create a similar file for the Epic Online Services SDK that will then be used to programmatically generate the desired definitions in Python.
--

=== A typical parameter type

[source, c]
....
/** The most recent version of the EOS_Achievements_QueryPlayerAchievements struct. */
#define EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_QueryPlayerAchievements function.
 */
EOS_STRUCT(EOS_Achievements_QueryPlayerAchievementsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievements are to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID for the user who is querying for player achievements. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));
....

[.notes]
--
This is an example of a parameter struct used by the Epic Games SDK functions.
Pretty much all functions use a similar struct, with the same ApiVersion entry which's expected value is provided through a `#define` macro.

As said previously, generic solutions tend to forego defines as they require preprocessing, which will make them disappear and - as you can see here - defines in the Epic Games SDK are load-bearing as they specify the API version being used. Thus, any solution can't just be chaining a processor and tokenizing its output.

Additionally, we want to keep comment information as they indicate which values we need to use - which also means that they will need to be parsed at some points.
--

== Getting to the intermediate representation

=== List of the lib's headers

[plantuml, format=svg]
----
@startuml
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/eos_include_headers.puml[]
@enduml
----

[.notes]
--
The lib's includes contain some platform-specific headers, however they only contain some platform-specifc structs that can safely be defined even on platforms that do not use them.

Another noteworthy file is `eos_base.h`, which contains all structural preprocessor macros for declarations in other files (e.g.: the EOS_STRUCT macro shown previously).

Finally, some of the `*_deprecated.inl` files actually have to be loaded as they are still referenced in functions headers.
--

=== Load the lib's headers

[source, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=indexation]
----

[source, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=eos_base_override]
----

=== Parse lib entries

[source, h]
----
include::resources/code_samples/eos_sdk/eos_results.h[]
----

[source%step, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=eos_result_parse]
----

=== Entries parse index

[source, py]
----
include::resources/code_samples/eos_spec/script_build_load.py[tag=line_start_flags]
----

=== Parsing loop

[plantuml%autofit, format=svg]
----
@startuml
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/eos_header_parsing_loop.puml[]
@enduml
----

[.notes]
--
Special cases include EOS_UI_ preprocessor macros as they need additional context, and single-line comments which are ignored.
--

=== Resulting json

[source, json]
----
include::resources/code_samples/eos_spec/spec_sample.json[]
----

[.notes]
--
This is a very limited example of what the JSON spec file looks like.
The metadata field provides information on the current SDK version and its download source, while other fields provide lists of header file entries.
--

== Getting to the code generation

=== Load all entries

[source, py]
----
include::resources/code_samples/eos_ext/entries.py[tag=entry]
----

[.notes]
--
For generation, all entries in the spec file are mapped to specialized Entry subclasses depending on their type (function, typedef, struct, ...).
Those classes provide dependency resolution information (via requires and provides) and a way to write the content of an object.
--

=== Resolve all entries' interdependencies

[source, py]
----
include::resources/code_samples/eos_ext/entries.py[tag=function_decl]

include::resources/code_samples/eos_ext/entries.py[tag=function_requires]

include::resources/code_samples/eos_ext/entries.py[tag=function_provides]

    # ...
----

[.notes]
--
As an example, the FunctionEntry Entry subclass requires the function's parameter types and return value's type and provides the function's name.
--

=== Associate structs and functions

[source.wrap.small-code, h]
----
EOS_DECLARE_FUNC(void) EOS_Achievements_QueryDefinitions(EOS_HAchievements Handle, const EOS_Achievements_QueryDefinitionsOptions* Options, void* ClientData, const EOS_Achievements_OnQueryDefinitionsCompleteCallback CompletionDelegate);
----

[plantuml%step%autofit.zoom-70, format=svg]
----
include::resources/uml/plantuml_skinparam.puml[]
include::resources/uml/ext_function_mapping.puml[]
----

[.notes]
--
As Python supports OOP while C does not, we want to be able to use the mapped structs as regular objects and call member functions instead of having to retrieve the corresponding functions manually every time.
Epic Games functions that can be used as member functions start with the name of the associated object, however we only have handles for most objects (prefixed with H) and thus need to be able to mix & match.

The matching logic splits the function's name on `_` then builds strings by joining subsets of the name's components, occasionally prefixing the second item with a `H` to match struct handles.
--

=== Write entries in order

[source, py]
----
include::resources/code_samples/eos_ext/init.py[tag=render]
----

[.notes]
--
15734 lines
--

== Code generation results

=== Defines

:code-source-path: ../resources/code_samples/code_gen_samples/define_copy_achievement
include::content/code_gen_template.adoc[]

=== Large enum types

:code-source-path: ../resources/code_samples/code_gen_samples/enum_result_type
include::content/code_gen_template.adoc[]

=== Large enum values

:code-source-path: ../resources/code_samples/code_gen_samples/enum_result_success
include::content/code_gen_template.adoc[]

=== Regular enum types

:code-source-path: ../resources/code_samples/code_gen_samples/enum_loginstatus
include::content/code_gen_template.adoc[]

=== Parameter structs

:code-source-path: ../resources/code_samples/code_gen_samples/struct
include::content/code_gen_template.adoc[]

=== Functions

:code-source-path: ../resources/code_samples/code_gen_samples/functions
include::content/code_gen_template.adoc[]

=== Struct member functions

:code-source-path: ../resources/code_samples/code_gen_samples/member_function
include::content/code_gen_template.adoc[]

=== Callback functions

:code-source-path: ../resources/code_samples/code_gen_samples/callback_function
include::content/code_gen_template.adoc[]

== A bit more on cffi

=== Resolve defines in headers

[source, sh]
--
gcc -E path/to/header.h
--

[.notes]
--
Using -E will result in GCC displaying the code after preprocessing : all define AND include macros will be resolved, you should then have the ability to copy/paste valid declarations from your desired header files from the output.

To display comments in the output, add the option `-C`.

To display the original defines, enable debugging and their display with `-dD`.
--

// https://runebook.dev/en/articles/python/library/ctypes/ctypes._CData._objects

=== C python modules dependencies

* python headers
* ffi headers

[.notes]
--
On Fedora: libffi-devel, libssl-devel
On Ubuntu: python3?-dev, libssl-dev, libffi-dev

The recommended usage of CFFI relies on the generation of c python modules instead of loading a DLL dynamically.
To use this, a compiler must be installed on the host as well as several headers (amongst which figure the header files for the current/target python version).
--

=== C python module compilation

[source, h]
--
include::resources/code/04_cffi_api/main.h[]
--

[source.cffi%step, py]
--
include::resources/code/04_cffi_api/main.py[tag=cffi_compile]
--

[source.cffi%step, py]
--
include::resources/code/04_cffi_api/main.py[tag=cffi_use]
--

[quote%step]
--
include::resources/code/04_cffi_api/main.out[tag=cffi_use]
--

== Thank you
